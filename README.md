![GitHub top language](https://img.shields.io/github/languages/top/sanyarise/checkComission)
![GitHub repo size](https://img.shields.io/github/repo-size/sanyarise/checkComission)
![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/sanyarise/checkComission)

<img align="right" width="50%" src="./images/i.jpg">
# checkComission

Описание:
Есть функция, которая принимает от всех модулей значение комиссии за предоставление услуг компании.
Размер комиссии может быть от 0 до 99.99
Максимальное количество знаков после запятой: 2
В базу данных записываются только целые значения, поэтому запятую приходится сдвигать на 2 знака.
Например для комиссии размером 1.5 значение в базе данных будет соответствовать 150
 
Работа с функцией не должна требовать каких-либо проверок перед отправкой значения.
Результат работы функции не должен требовать перепроверки со стороны модулей, т.е. возвращаемое значение всегда считается корректным.

Разработчик реализовал функцию проверки корректности ввода и преобразования вводимого значения.
Со стороны клиентов поступают жалобы на то, что вводимая ими комиссия записывается не верно или не записывается вовсе, однако все утверждают, что заполняют корректное значение с дробной частью или без.

Задание для разработчика:
Исправьте функцию проверки вводимого значения и дальнейшего преобразования для корректной записи в базу данных итогового значения.
Под данными для записи в базу данных подразумевается результат работы функции check_commission()

### Решение:
1. При конвертированиях и других операциях со строками в них могут появляться пробелы или невидимые непечатаемые символы (перенос строки, табуляция и другие), естественно, с такими символами строка не сможет спарситься в числовое значение. Поэтому первым делом входящая строка очищается от пробелов и непечатаемых символов
2. Далее идет проверка строки на пустоту и если строка пустая, выводится сообщение об этом и происходит выход из функции
3. Часто в строках встречается запятая вместо точки (даже в описании есть количество символов после запятой, хотя по факту в Go используется точка), поэтому строка приводится к слайсу рун, итерируемся по слайсу в цикле, если среди символов встречается запятая, заменяем ее на точку.
4. Если точка или запятая присутствует, то дальше проверяется сколько знаков после точки и если их более двух, выводится сообщение об этом и происходит выход из функции
5. После этого приводим слайс рун обратно к строке и парсим строку в значение float64. Если парсинг прошел успешно, проводим проверку того, что полученное число не меньше 0 и не больше 99.99, если это не так, выводим сообщение и выходим из функции.
6. В процессе решения задачи было обнаружено, что некоторые значения при парсинге в float64 и дальнейшем приведении к uint64 из-за потери точности дают неверный результат (в частности это явление было обнаружено случайно на числе 0.29). Чтобы избежать подобных казусов, используется функция math.Round() после умножения значения из строки на 100 для смещения запятой.
7. Числа, которые начинаются с точки или заканчиваются точкой, функция strconv.ParseFloat парсит, поэтому я оставил такие значения, как корректные, однако, тут нужно уточнять по требованиям насколько они допустимы (.25 или 25.)
8. Добавлены юнит тесты, чтобы проверить корнер-кейсы
9. Для запуска тестов достаточно запустить в консоли команду `make test`